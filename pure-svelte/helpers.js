
export let  clearOptions = () => game.options = [],
            offerUnsettled = () => offer( false,  false, ["unsettled_planets"], "subchoices", finish),
            getActionCardPhases = () => actioncardphases,
            getActvActn = () => getActPlyr().activeaction,
            getActvRole = () => getActPlyr().activerole,
            getChoice = () => game.choices[0].name,
            getChoices = () => game.choices,
            getSubChoice = () => getSubChoices()[0],
            getSubChoices = () => game.subchoices,
            finish = (cond=false) => phasefinishfunction(cond),
            getActPlyr = () => game.players[game.acting_player_index],
            getLeadPlyr = () => game.players[game.leading_player_index],
            //offer = (skip,multiple,choices,route,callback) => offer(skip,multiple,choices,route,callback),
            genActionPhase = (name,actions,phase,choices=[],cond=false) => ({ [name] : ()=>{ if ( actions.includes(getActvActn()) || choices.includes(getChoice())) {finish(cond);} else { phase() } }}),
            simpleOffer = (choices) => offer( false, false, ["options", choices.reduce((acc,cur)=>[...acc,{name:cur}],[])], "choices", finish),
            wrappedOffer = (choices) => () => simpleOffer(choices),
            getActionCorePhases = () => corephases.reduce((acc,cur)=>[...acc,cur.actn],[]).reduce((acc,cur)=>[...acc,...cur],[]),
            getLeadCorePhases = () => corephases.reduce((acc,cur)=>[...acc,cur.lead],[]).reduce((acc,cur)=>[...acc,...cur],[]),
            getFollowCorePhases = () => corephases.reduce((acc,cur)=>[...acc,cur.fllw],[]).reduce((acc,cur)=>[...acc,...cur],[]),
            genLeadPhase = (name,actions,phase,choices=[],cond=false) => ({ [name] : ()=>{ if ( actions.includes(getActvRole()) || choices.includes(getChoice())) {finish(cond);} else { phase() } }}),
            genFollowPhase = (name,actions,phase,choices=[],cond=false) => ({ [name] : ()=>{ if ( actions.includes(getActvRole()) || choices.includes(getChoice())) {finish(cond);} else { phase() } }}),
            genEmptyCard = (type, name, symbols, extras={}) => ({ type: type,selected: false, name: name, selected: false, icons: {...{ survey: 0, warfare: 0, colonize: 0, produce: 0, trade: 0, research: 1},...symbols},image: null, ...extras}),
            tallyIcons = (dest,src) => ["survey","warfare","trade","produce","research",/*"colonize"*/].forEach( icon => dest.icons[icon] += src.icons[icon] ),
            handToLimboWithLimboDuplicatePurge = (plyr,card) => { rmFromField("limbo",plyr,card); handToLimbo(plyr,card);},
            handToLimbo = (plyr,card) => {playToField("limbo",plyr,card,'discard'); rmFromField("hand",plyr,card);},
            limboToHand = (plyr,card) => {playToField("hand",plyr,card,''); rmFromField("limbo",plyr,card);},
            playToField = (fld,plyr,card,fDest) => plyr[fld] = [...plyr[fld], { finDest: fDest, ...card }],
            rmFromField = (fld,plyr,card) => plyr[fld] = plyr[fld].filter(el => card.id != el.id),
            boostWithIcons = (plyr, src) => src.icons.forEach(icon => plyr.bstIcons[icon]++),
            resetIconBoost = (plyr) => plyr.bstIcons = {survey: 0, warfare: 0, colonize: 0, produce: 0, trade: 0, research: 0 },
            resetSelection = (selected) => selected.forEach((s) => s.selected = false),
            offlineOrIsClientTurn = () => (lobby.screenname == getActPlyr().name || !lobby.online),
            setChoice = (chc) => game[game.displayinfo.choicelabel] = chc,
            cleanOptions = () => game.options=[],
            displayPlanets = () => game.displayinfo.center_or_planets = false,
            displayCenter = () => game.displayinfo.center_or_planets = true,
            clearChoices = () => game[choice_label] = [],
            setDisplayInfo = (zone,multiple,skippable,label) => game.displayinfo = {...game.displayinfo,...{selectionzone:zone,allowformultipleselections:multiple,showoptiontoskip:skippable,choicelabel:label}},
            getAllCards = (plyr) => [...plyr.deck,...plyr.discard, ...plyr.limbo, ...plyr.hand],
            isPlanet = (p) => p.type=='planet' || p.type!=='fertile' || p.type!=='metallic' || p.type!=='advanced',
            chkForPerm = (perm) => getActPlyr().permanents.filter( (el)=>el.type==perm ).length != 0,
            range = (min,max) => (min <= max) ? [...range(min, max-1),max] : [],
            singleCllBck = (cllBck,e,func) => () => {func(); document.removeEventListener(e,this); cllBck();},
            produceTradeHelper = (filled,planets,resources,func=()=>{}) => { let prd = {blue:0,green:0,purple:0,red:0}; planets.forEach((planet) =>  planet.production_zones.forEach((zone)=>{     if (!zone.filled && resources > 0) {         zone.filled = filled;         prd[zone.type]++;         resources--;         func()     }  }) );return prd;};
